trigger:
  - main

variables:
  group: 'azure-connection-vars'
  azureServiceConnection: 'MyAzureServiceConnection'
  vmImageName: 'ubuntu-latest'
  backendResourceGroup: 'terraform-backend-rg'
  dockerfilePath: '$(Build.SourcesDirectory)/Dockerfile'
  dockerImageName: 'myflaskapp'
  terraformVersion: '1.9.6'

stages:
- stage: TerraformBackend
  displayName: 'Create Terraform Backend'
  jobs:
  - job: CreateBackend
    pool:
      vmImage: $(vmImageName)
    steps:
    - task: TerraformInstaller@0
      inputs:
        terraformVersion: $(terraformVersion)
    - task: TerraformTaskV3@3
      inputs:
        provider: 'azurerm'
        command: 'init'
        workingDirectory: '$(System.DefaultWorkingDirectory)/terraform-backend'
        backendServiceArm: '$(azureServiceConnection)'
        backendAzureRmResourceGroupName: '$(backendResourceGroup)'
        backendAzureRmStorageAccountName: 'tfstate$(Build.BuildId)'
        backendAzureRmContainerName: 'tfstate'
        backendAzureRmKey: 'terraform.tfstate'
    - task: TerraformTaskV3@3
      inputs:
        provider: 'azurerm'
        command: 'apply'
        workingDirectory: '$(System.DefaultWorkingDirectory)/terraform-backend'
        environmentServiceNameAzureRM: '$(azureServiceConnection)'

- stage: InfrastructureDeployment
  displayName: 'Deploy Azure Infrastructure'
  dependsOn: TerraformBackend
  jobs:
  - job: DeployInfrastructure
    pool:
      vmImage: $(vmImageName)
    steps:
    - task: TerraformInstaller@0
      inputs:
        terraformVersion: $(terraformVersion)
    - task: TerraformTaskV3@3
      inputs:
        provider: 'azurerm'
        command: 'init'
        workingDirectory: '$(System.DefaultWorkingDirectory)/azure-terraform-infra'
        backendServiceArm: '$(azureServiceConnection)'
        backendAzureRmResourceGroupName: '$(backendResourceGroup)'
        backendAzureRmStorageAccountName: 'tfstate$(Build.BuildId)'
        backendAzureRmContainerName: 'tfstate'
        backendAzureRmKey: 'terraform.tfstate'
    - task: TerraformTaskV3@3
      inputs:
        provider: 'azurerm'
        command: 'apply'
        workingDirectory: '$(System.DefaultWorkingDirectory)/azure-terraform-infra'
        environmentServiceNameAzureRM: '$(azureServiceConnection)'
    - task: AzureCLI@2
      name: SetInfraVariables
      inputs:
        azureSubscription: '$(azureServiceConnection)'
        scriptType: 'bash'
        scriptLocation: 'inlineScript'
        inlineScript: |
          APP_SERVICE_NAME=$(terraform output -raw app_service_name)
          ACR_LOGIN_SERVER=$(terraform output -raw acr_login_server)
          RESOURCE_GROUP_NAME=$(terraform output -raw resource_group_name)
          echo "##vso[task.setvariable variable=appServiceName;isOutput=true]$APP_SERVICE_NAME"
          echo "##vso[task.setvariable variable=acrLoginServer;isOutput=true]$ACR_LOGIN_SERVER"
          echo "##vso[task.setvariable variable=resourceGroupName;isOutput=true]$RESOURCE_GROUP_NAME"
      workingDirectory: '$(System.DefaultWorkingDirectory)/azure-terraform-infra'
    - task: AzureCLI@2
      name: CreateACRServiceConnection
      inputs:
        azureSubscription: '$(azureServiceConnection)'
        scriptType: 'bash'
        scriptLocation: 'inlineScript'
        inlineScript: |
          ACR_NAME=$(terraform output -raw acr_name)
          ACR_RESOURCE_GROUP=$(terraform output -raw acr_resource_group)
          SERVICE_CONNECTION_NAME="acr-service-connection"
          
          # Create service connection
          az devops service-endpoint azurecr create --name "$SERVICE_CONNECTION_NAME" \
                                                    --azure-rm-service-principal-id $(servicePrincipalId) \
                                                    --azure-rm-subscription-id $(subscriptionId) \
                                                    --azure-rm-subscription-name "$(subscriptionName)" \
                                                    --azure-rm-tenant-id $(tenantId) \
                                                    --acr-name "$ACR_NAME" \
                                                    --project "$(System.TeamProject)" \
                                                    --detect false
          
          # Set the output variable
          echo "##vso[task.setvariable variable=acrServiceConnection;isOutput=true]$SERVICE_CONNECTION_NAME"
      workingDirectory: '$(System.DefaultWorkingDirectory)/azure-terraform-infra'


- stage: BuildAndPushImage
  displayName: 'Build and Push Docker Image'
  dependsOn: InfrastructureDeployment
  variables:
    acrServiceConnection: $[ stageDependencies.InfrastructureDeployment.DeployInfrastructure.outputs['CreateACRServiceConnection.acrServiceConnection'] ]
    acrLoginServer: $[ stageDependencies.InfrastructureDeployment.DeployInfrastructure.outputs['SetInfraVariables.acrLoginServer'] ]
  jobs:
  - job: BuildPush
    pool:
      vmImage: $(vmImageName)
    steps:
    - task: Docker@2
      inputs:
        containerRegistry: '$(acrServiceConnection)'
        repository: '$(dockerImageName)'
        command: 'buildAndPush'
        Dockerfile: '$(dockerfilePath)'
        tags: |
          $(Build.BuildId)
          latest

- stage: VerifyDeployment
  displayName: 'Verify Deployment'
  dependsOn: BuildAndPushImage
  variables:
    appServiceName: $[ stageDependencies.InfrastructureDeployment.DeployInfrastructure.outputs['SetInfraVariables.appServiceName'] ]
    resourceGroupName: $[ stageDependencies.InfrastructureDeployment.DeployInfrastructure.outputs['SetInfraVariables.resourceGroupName'] ]
  jobs:
  - job: WaitAndVerify
    pool:
      vmImage: $(vmImageName)
    steps:
    - task: Delay@1
      inputs:
        delayForMinutes: '2'
    - task: AzureWebAppContainer@1
      inputs:
        azureSubscription: '$(azureServiceConnection)'
        appName: '$(appServiceName)'
        deployToSlotOrASE: true
        resourceGroupName: '$(resourceGroupName)'
        slotName: 'production'
        containerImageOverride: '$(acrLoginServer)/$(dockerImageName):$(Build.BuildId)'

- stage: VerifyAppService
  displayName: 'Verify App Service Deployment'
  dependsOn: VerifyDeployment
  variables:
    appServiceName: $[ stageDependencies.InfrastructureDeployment.DeployInfrastructure.outputs['SetInfraVariables.appServiceName'] ]
    resourceGroupName: $[ stageDependencies.InfrastructureDeployment.DeployInfrastructure.outputs['SetInfraVariables.resourceGroupName'] ]
    acrLoginServer: $[ stageDependencies.InfrastructureDeployment.DeployInfrastructure.outputs['SetInfraVariables.acrLoginServer'] ]
  jobs:
  - job: CheckDeployment
    pool:
      vmImage: $(vmImageName)
    steps:
    - task: AzureAppServiceSettings@1
      inputs:
        azureSubscription: '$(azureServiceConnection)'
        appName: '$(appServiceName)'
        resourceGroupName: '$(resourceGroupName)'
        appSettings: |
          [
            {
              "name": "DOCKER_CUSTOM_IMAGE_NAME",
              "value": "$(acrLoginServer)/$(dockerImageName):$(Build.BuildId)"
            }
          ]
    - task: AzureCLI@2
      inputs:
        azureSubscription: '$(azureServiceConnection)'
        scriptType: 'bash'
        scriptLocation: 'inlineScript'
        inlineScript: |
          CURRENT_IMAGE=$(az webapp config container show --name $(appServiceName) --resource-group $(resourceGroupName) --query 'image' -o tsv)
          EXPECTED_IMAGE="$(acrLoginServer)/$(dockerImageName):$(Build.BuildId)"
          if [ "$CURRENT_IMAGE" = "$EXPECTED_IMAGE" ]; then
            echo "Deployment verified: Current image matches expected image."
          else
            echo "##vso[task.logissue type=error]Deployment verification failed: Current image ($CURRENT_IMAGE) does not match expected image ($EXPECTED_IMAGE)"
            exit 1
          fi
    - task: AzureCLI@2
      inputs:
        azureSubscription: '$(azureServiceConnection)'
        scriptType: 'bash'
        scriptLocation: 'inlineScript'
        inlineScript: |
          KEY_VAULT_URL=$(az webapp config appsettings list --name $(appServiceName) --resource-group $(resourceGroupName) --query "[?name=='KEY_VAULT_URL'].value" -o tsv)
          if [ -z "$KEY_VAULT_URL" ]; then
            echo "##vso[task.logissue type=error]KEY_VAULT_URL is not set in App Service settings"
            exit 1
          else
            echo "KEY_VAULT_URL is correctly set in App Service settings"
          fi